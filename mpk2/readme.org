#+TITLE: MPK from Suda sensei
The package consists of the following 3 main parts: ~gen~ for matrix
generation, ~driver~ to create the scheduling/communication pattern
and finally ~mpktest~ to run the computation.
* Input generation: ~gen~
  See program output without parameters for further information.
** Input:
   - type :: The type of the generated matrix.
   - size :: Size of the generated matrix.
   - ghead :: Name of the generated file.
** Output:
   - ghead.g0 :: Graph/matrix (without vertex values).
   - ghead.co :: Coordinates for graphical interpretation.
* Communication pattern generation: ~driver~
** Input:
   - ghead :: Input name used by ~gen~.
   - npart :: Number of partitions used.
   - nlevel :: Target level which should be calculated.
   - nphase :: Number of phases before doing the "skirt" operation.
** Output:
   - levels :: Levels reached in each phase (~l$P~ files).
   - weights :: Weights (calculated from levels) used for partitioning
                (~g$P~ files).
   - partitions :: partitioned graphs (~g$P.part.$NPART~ files).
   - skirt :: File ~s$NPHASE~.
   ~$P~ is the index of the phase.
** Operation
   The program executes a bunch of ~system()~ calls, to run other
   binaries.  The line executed is written using ~sprintf()~ to the
   ~line~ variable.  ~driver.c~ basically does the following:
   - ~mkdir $DIR~ where ~$DIR~ is ~$GHEAD_$NPART_$NLEVEL_$NPHASE~.
   - ~cp $GHEAD.g0 $DIR/g0~ where ~$DIR~ is the directory created in
     the previous ~system()~ call.
   - Logging: ~echo graph $GHEAD, npart $NPART, nlevel $NLEVEL, nphase
     $NPHASE > $DIR/log~ (line 57).
   - For ~$P~ from ~0~ to ~$NPHASE - 1~:
     - Partition graph: ~gpmetis $DIR/g$P $NPART~ (with additional
       logging).
     - Compute levels: ~comp level $DIR/g0 x $DIR/g$P.part.$NPART~
       with as output ~$DIR/l$P~ and as the starting point
       ~$DIR/l${P-1}~ after the first phase.
     - Logging: ~stat $DIR/lP $NLEVEL >> $DIR/log~.
     - Compute weights with ~$DIR/g${P+1}~ as output and after the
       initial phase with ~$DIR/l{P-1}~ as the input.
   Finally calculate the skirt:
   - If ~$NPHASE > 0~, so there is a positive number of phases,
     calculate the skirt:
     - The skirt is calculated with the first partitioning: ~skirt
       $NLEVEL $DIR/g0 x $DIR/g0.part.$NPART $DIR/l${P-1} $DIR/s$P~
       (followed by a ~stat~ command for logging).
   - Else, if ~$NPHASE == 0~, the graph needs to be partitioned,
     before the skirt can be calculated with ~gpmetis~ followed by a
     ~stat~ command (see source for details).
* Computation: ~mpktest~
** Input:
   - dir :: The directory name generated by ~driver~.
** Output:
   - stdout :: The output is printed on the screen.
** Operation
   ~mpktest~ measures the performance of the MPK algorithm:
   - The ~read_mpk()~ function is called to load the data,
   - ~prep_mpk()~ performs some checks and sets ~mpk_t::tlist[]~'s ~n~
     and ~idx[]~ members, where the ~n~ is the number of vertices
     calculated by the given task in ~tlist[]~ and ~idx[]~ is a list
     of pointers to the indices calculated by the task.
   - The ~double *vv~ vector is allocated and initialises.
   - Measurements are performed on different calls to the mpk
     algorithm, with different scheduling approaches.
*** ~read_mpk(char *)~
**** Input
     The name of a directory generated by ~driver~.
**** Output
     A pointer to a (partially) initialised ~mpk_t mg~ object.
     - ~mg->plist[]~ contains the partition for each phase (as a
       ~part_t~ graph).
     - ~mg->llist[]~ contains the levels reached at each phase.
     - ~mg->sg~ contains the skirt.
     - ~mg->idxsrc[]~ is an array of ~longs~ of length
       ~mg->idxallocsize~ which is equal to ~mg->n * nlevel~ plus
       ~sk->levels[i] + 1~ for every vertex ~i~.
**** Operation 
     - Obtain ~npart~, ~nlevel~, ~nphase~ from the directory name.
     - Read the graph ~g0~ from the directory.
     - Allocate an ~mpk_t mp~ object with ~new_mpk(g0, npart,
       nlevel, nphase)~.
     - For each phase read the partition and level files
       ~g$P.part.$NPART~ (store it in ~mg->plist[]~) and ~l$P~
       (store it in ~mg->llist[]~).
     - Read the skirt ~s$NPHASE~ (store it in ~mg->sk~).
     - Allocate ~mg->idxsrc~
*** ~prep_mpk(mpk_t*, double*)~
**** Input
    - ~mpk_t *mg~ from ~read_mpk()~.
    - ~double *vv~ allocated with ~(nlevel + 1) * n~ elements (one
      vector has ~n~ elements, and there are ~nlevel + 1~ vectors, the
      input vector and one for each level of MPK).  ~vv~ is not
      actually used here, only for testing purposes.
**** Output
     - ~mg~ with ~mg->tlist[].n~ and ~mg->tlist[].idx[]~ filled: Let
       ~tl = mg->tlist[p]~, then ~tl.n~ is the number of vertices
       calculated in partition ~p~, and ~tl.idx[0..tl.n-1]~ the
       indices of these vertices in ~vv~ (calculated by ~l * n + i~
       where ~l~ is the level, ~i~ is the vertex, ~n~ the number of
       vertices).
**** Operation
     - perform checks
       - check that levels are correct
         - all levels are >= 0 in the first phase
         - all levels don't decrease compared to the previous phase
       - check the skirts
         - nphase = 0 a special case: check "skirt level" <= nlevel
         - nphase > 0: check level + "skirt level" <= nlevel
     - set vv[] to -1.0 (all ~n * (nlevel + 1)~ values)
     - set 0th levels vv[] to initial partitions * 100.0
     - init:
       - tcount=0
       - prevl=[0,0,...]: previous levels
       - prevlmin=0: previous lmin (min of levels)
     - The Main Loop: for each phase
       - init: tsize[0..npart] = 0, lmin, lmax
       - lmax = min(lmax, nlevel), i.e. cap lmax at nlevel
       - loop1: for every node, every level (prevlmin+1 to lmax)
         - assuming prevl[i] < level <= ll[i] (ll is mg->llist[phase]->level)
           - prevl[] is the level reached in the previous phase
           - ll[] is the level to be reached in the current phase
           - do some checks
             - check: vv[] == -1 (if vv[] > 0 then error)
             - check: every adjacent node from the previous level is calculated (>= 0)
             - and check: adjacent node is in a different partition OR magic (see below)?
               Adjacent value mode 100 equals phase??? Why/how? (see next line)
           - set vv for level and node to current partition * 100 + phase
           - increment tsize for the current partition
       - loop2: in the mg->tlist[] for the current phase
         - set the task size and indices and clean up
           - tlist[i].n = tsize[]
           - tlist[i].idx = mg->idxsrc + tcount
           - tcount += tsize[i]
           - reinitalize tsize[i] to 0
       - loop3: as loop1, but now set task.idx[] to l * n + i
         - tsize[] is the counter - current index
       - update loop variables, prevl, prevlmin
     - Skirt loop: similar to the main loop
     - init vv[] = [1., 1., ..] at level 0, and [-1., ...] everything else
     - measurements from mpkexec.c
       - spmv_exec_seq()
       - spmv_exec_par()
       - exec_mpk_xd()
       - Hidden under #if 1
         - exec_mpk_xs()
         - exec_mpk_xd()
         - exec_mpk_is()
         - exec_mpk_id()
       - Hidden under #if TRANS
         - exec_mpkt()
     - 3+1 special =#define=s
       - ONEVEC, ONEENT, TRANS, and DETAIL
