#+TITLE: MPK from Suda sensei
The package consists of the following 3 main parts: ~gen~ for matrix
generation, ~driver~ to create the scheduling/communication pattern
and finally ~mpktest~ to run the computation.
* Input generation: ~gen~
  See program output without parameters for further information.
** Input:
   - type :: The type of the generated matrix.
   - size :: Size of the generated matrix.
   - ghead :: Name of the generated file.
** Output:
   - ghead.g0 :: Graph/matrix (without vertex values).
   - ghead.co :: Coordinates for graphical interpretation.
* Communication pattern generation: ~driver~
** Input:
   - ghead :: Input name used by ~gen~.
   - npart :: Number of partitions used.
   - nlevel :: Target level which should be calculated.
   - nphase :: Number of phases before doing the "skirt" operation.
** Output:
   - levels :: Levels reached in each phase (~l$P~ files).
   - weights :: Weights (calculated from levels) used for partitioning
                (~g$P~ files).
   - partitions :: partitioned graphs (~g$P.part.$NPART~ files).
   - skirt :: File ~s$NPHASE~.
   ~$P~ is the index of the phase.
** Operation
   The program executes a bunch of ~system()~ calls, to run other
   binaries.  The line executed is written using ~sprintf()~ to the
   ~line~ variable.  ~driver.c~ basically does the following:
   - ~mkdir $DIR~ where ~$DIR~ is ~$GHEAD_$NPART_$NLEVEL_$NPHASE~.
   - ~cp $GHEAD.g0 $DIR/g0~ where ~$DIR~ is the directory created in
     the previous ~system()~ call.
   - Logging: ~echo graph $GHEAD, npart $NPART, nlevel $NLEVEL, nphase
     $NPHASE > $DIR/log~ (line 57).
   - For ~$P~ from ~0~ to ~$NPHASE - 1~:
     - Partition graph: ~gpmetis $DIR/g$P $NPART~ (with additional
       logging).
     - Compute levels: ~comp level $DIR/g0 x $DIR/g$P.part.$NPART~
       with as output ~$DIR/l$P~ and as the starting point
       ~$DIR/l${P-1}~ after the first phase.
     - Logging: ~stat $DIR/lP $NLEVEL >> $DIR/log~.
     - Compute weights with ~$DIR/g${P+1}~ as output and after the
       initial phase with ~$DIR/l{P-1}~ as the input.
   Finally calculate the skirt:
   - If ~$NPHASE > 0~, so there is a positive number of phases,
     calculate the skirt:
     - The skirt is calculated with the first partitioning: ~skirt
       $NLEVEL $DIR/g0 x $DIR/g0.part.$NPART $DIR/l${P-1} $DIR/s$P~
       (followed by a ~stat~ command for logging).
   - Else, if ~$NPHASE == 0~, the graph needs to be partitioned,
     before the skirt can be calculated with ~gpmetis~ followed by a
     ~stat~ command (see source for details).
* Computation: ~mpktest~
** Input:
   - dir :: The directory name generated by ~driver~.
** Output:
   - stdout :: The output is printed on the screen.
** Operation
   ~mpktest~ measures the performance of the MPK algorithm:
   - The ~read_mpk()~ function is called to load the data,
   - ~prep_mpk()~ performs some checks and sets ~mpk_t::tlist[]~'s ~n~
     and ~idx[]~ members, where the ~n~ is the number of vertices
     calculated by the given task in ~tlist[]~ and ~idx[]~ is a list
     of pointers to the indices calculated by the task.
   - The ~double *vv~ vector is allocated and initialises.
   - Measurements are performed on different calls to the mpk
     algorithm, with different scheduling approaches.
   - The output is printed using the ~show_exinfo()~ and
     ~check_error()~ functions.
*** ~read_mpk(char *)~
**** Input
     The name of a directory generated by ~driver~.
**** Output
     A pointer to a (partially) initialised ~mpk_t mg~ object.
     - ~mg->plist[]~ contains the partition for each phase (as a
       ~part_t~ graph).
     - ~mg->llist[]~ contains the levels reached at each phase.
     - ~mg->sg~ contains the skirt.
     - ~mg->idxsrc[]~ is an array of ~longs~ of length
       ~mg->idxallocsize~ which is equal to ~mg->n * nlevel~ plus
       ~sk->levels[i] + 1~ for every vertex ~i~.
**** Operation
     - Obtain ~npart~, ~nlevel~, ~nphase~ from the directory name.
     - Read the graph ~g0~ from the directory.
     - Allocate an ~mpk_t mp~ object with ~new_mpk(g0, npart,
       nlevel, nphase)~.
     - For each phase read the partition and level files
       ~g$P.part.$NPART~ (store it in ~mg->plist[]~) and ~l$P~
       (store it in ~mg->llist[]~).
     - Read the skirt ~s$NPHASE~ (store it in ~mg->sk~).
     - Allocate ~mg->idxsrc~
*** ~prep_mpk(mpk_t*, double*)~
**** Input
    - ~mpk_t *mg~ from ~read_mpk()~.
    - ~double *vv~ allocated with ~(nlevel + 1) * n~ elements (one
      vector has ~n~ elements, and there are ~nlevel + 1~ vectors, the
      input vector and one for each level of MPK).  ~vv~ is not
      actually used here, only for testing purposes.
**** Output
     - ~mpk_t *mg~ with ~mg->tlist[].n~ and ~mg->tlist[].idx[]~ filled: Let
       ~tl = mg->tlist[p]~, then ~tl.n~ is the number of vertices
       calculated in partition ~p~, and ~tl.idx[0..tl.n-1]~ the
       indices of these vertices in ~vv~ (calculated by ~l * n + i~
       where ~l~ is the level, ~i~ is the vertex, ~n~ the number of
       vertices).
**** Operation
     ~prep_mpk()~ performs a lot of checks:
      - Check that levels in ~mg->llist[]~ are correct
        - all levels are >= 0 in the first phase,
        - all levels are large or equal than in the previous phase.
      - Check the skirts levels:
        - If ~nphase~ is 0: check skirt level ~mg->sg->levels~ <=
          ~nlevel~.
        - If ~nphase > 0~: check current level + skirt level" <=
          ~nlevel~.
      - Initialise ~vv[]~ to -1.0 (all ~n * (nlevel + 1)~ values).
      - Set 0th levels ~vv[]~ (first ~n~ values) to initial partition
        id * 100.0
***** Main loop
      This loop has 3 "subloops".  The second loop sets values of
      ~mg->tlist[p].n~ and ~mg->tlist[p].idx~ based on the values
      obtained in ~tsize[p]~ from the first loop, and finally the last
      loop fills the values of the ~mg->tlist[p].idx[]~ array.
      - Initialisation:
        - ~tcount = 0~ is the task counter.
        - ~prevl = [0, 0, ...]~ is a pointer to ~n~ values indicating
          the level reached in the previous phase.
        - ~prevlmin = 0~ is the minimum of levels in the previous
          phase.
      - *The Main loop* is executed on each *phase*:
        - Initialise ~tsize[0..npart-1]~ to 0, ~lmin~ to the minimum,
          ~lmax~ to the maximum of the levels of the current phase.
        - ~lmax = min(lmax, nlevel)~: cap ~lmax~ at ~nlevel~.
        - Loop 1: for every node, every level from ~prevlmin+1~ to
          ~lmax~,
          - but only for levels which need to be calculated in the
            current phase for the current vertex i.e. ~prevl[i] <
            level <= ll[i]~ where ~ll~ is ~mg->llist[phase]->level~.
            - Perform some checks:
              - check: ~vv[] == -1~ (if ~vv[] > 0~ then error)
              - check: every adjacent node from the previous level is calculated (>= 0)
              - and check: adjacent node is in a different partition
                OR adjacent values (from the previous level) mod 100
                equal phase (see next line).
            - Set ~vv[i]~ for level and node to current partition *
              100 + current phase (which explains the previous check).
            - Increment ~tsize[p]~ for the current partition.
        - Loop 2: set the task size (number of vertices to be
          processed to be processed in that partition) and indices (in
          ~vv~) of those vertices (i.e. taking the level into account)
          for the ~mg->tlist[]~ of the current phase i.e. for ~tl =
          mg->tlist + phase * npart~:
          - ~tl[p].n = tsize[p]~,
          - ~tl[p].idx = mg->idxsrc + tcount~,
          - ~tcount += tsize[p]~ (~tcount~ is the counter),
          - reinitalize ~tsize[i]~ to 0
        - Loop 3: fill ~tl[p].idx[]~: the iteration is same as for
          loop 1 (every node, all levels in the current phase), but
          now set ~tl[p].idx[tsize[p]]~ to ~l * n + i~ (~tsize[]~ is
          the counter),
        - Update loop variables ~prevl~, ~prevlmin~.
      - Skirt loop: similar to the main loop
      - Initialise ~vv[] = [1., 1., ..]~ for level 0, and [-1., ...] everything else.
      - Measurements are made by calling ~omp_get_wtime()~ and taking
        the minimum out of 5 measurements. The measured functions can
        be found in ~mpkexec.c~:
        - ~spmv_exec_seq()~ :: sequential implementation.
        - ~spmv_exec_par()~ :: parallel implementation not using MPK.
        - ~exec_mpk_xs()~ :: both phases and partitions are executed
             in parallel (static scheduling for partitions).
        - ~exec_mpk_xd()~ :: both phases and partitions are executed
             in parallel (dynamic scheduling for partitions).
        - ~exec_mpk_is()~ :: only partitions are executed in parallel
             (static scheduling).
        - ~exec_mpk_id()~ :: only partitions are executed in parallel
             (dynamic scheduling).

